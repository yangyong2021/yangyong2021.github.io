<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nacos安装指南</title>
      <link href="/2023/10/26/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
      <url>/2023/10/26/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402161102887.png" alt="image-20210402161102887"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402161130261.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402162251093.png" alt="image-20210402162251093"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402162526774.png" alt="image-20210402162526774"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402162709515.png" alt="image-20210402162709515"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402161102887.png" alt="image-20210402161102887"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402161130261.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402163715580.png" alt="image-20210402163715580"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="/./Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/image-20210402164414827.png" alt="image-20210402164414827"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos&#x2F;bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 微服务项目</title>
      <link href="/2023/10/25/Springboot%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/10/25/Springboot%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>回顾将本地非空项目和远程新建仓库相关联，首先进入到本地项目文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">git init</span><br><span class="line">// 重新路由</span><br><span class="line"> git remote add origin https://github.com/yangyong2021/springcloud_demo.git</span><br><span class="line">// 添加到本地仓库</span><br><span class="line">git add .</span><br><span class="line">// 提交</span><br><span class="line">git commit -m <span class="string">&#x27;描述信息&#x27;</span></span><br><span class="line">// 推送到远程仓库</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h3 id="1-跨服务远程调用"><a href="#1-跨服务远程调用" class="headerlink" title="1. 跨服务远程调用"></a>1. 跨服务远程调用</h3><p>使用<code>RestTemplate</code>注册远程调用</p><h4 id="1-1-在配置类中添加RestTemplate"><a href="#1-1-在配置类中添加RestTemplate" class="headerlink" title="1.1 在配置类中添加RestTemplate"></a>1.1 在配置类中添加<code>RestTemplate</code></h4><blockquote><p>需要在启动类上添加<code>@ServletComponentScan</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-使用RestTemplate发送http请求"><a href="#1-2-使用RestTemplate发送http请求" class="headerlink" title="1.2 使用RestTemplate发送http请求"></a>1.2 使用<code>RestTemplate</code>发送http请求</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrderById</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span>&#123;</span><br><span class="line">   <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getOrderById(orderId);</span><br><span class="line">   <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://127.0.0.1:8083/user/&quot;</span>+ order.getUserId();</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">   order.setUser(user);</span><br><span class="line">   <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Eureka注册中心"><a href="#2-Eureka注册中心" class="headerlink" title="2. Eureka注册中心"></a>2. Eureka注册中心</h3><p>在Eureka框架中，微服务角色分为两类：</p><ul><li><p>EurekaServer： 服务端，注册中心</p><blockquote><p>记录服务信息、心跳监控</p></blockquote></li><li><p>EurekaClient：客户端</p><blockquote><p>Provider： 服务提供者</p></blockquote><p>注册自己信息到EurekaServer</p><p>每隔30s向EurekaServer发送心跳</p><blockquote><p>Consumer：服务消费者</p></blockquote><p>根据服务名称从EurekaServer中拉取服务列表</p><p>基于服务列表做负载均衡，选择其中之一做远程调用</p></li></ul><h3 id="3-搭建Eureka注册中心"><a href="#3-搭建Eureka注册中心" class="headerlink" title="3. 搭建Eureka注册中心"></a>3. 搭建Eureka注册中心</h3><ul><li><p>创建项目，引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写启动类，添加@EnableEurekaServer注解</p></li><li><p>添加application.yml文件，编写相关配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">application:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eurekaserver</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">  <span class="attr">service-url:</span></span><br><span class="line">   <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-将UserService注册到Eureka中"><a href="#3-1-将UserService注册到Eureka中" class="headerlink" title="3.1 将UserService注册到Eureka中"></a>3.1 将UserService注册到Eureka中</h4><ol><li><p>引依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加.yml文件配置信息</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">application:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">  <span class="attr">service-url:</span></span><br><span class="line">   <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-在order-service完成服务拉取"><a href="#4-在order-service完成服务拉取" class="headerlink" title="4. 在order-service完成服务拉取"></a>4. 在order-service完成服务拉取</h3><p>服务拉取是基于服务名称获取服务列表，然后对服务列表做负载均衡</p><ul><li><p>修改OrderService对的代码，修改访问路径url地址，用服务名代替ip、端口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span>+ order.getUserId();</span><br></pre></td></tr></table></figure></li><li><p>在启动类中的RestTemplate添加<strong>负载均衡</strong>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-Ribbon负载均衡"><a href="#5-Ribbon负载均衡" class="headerlink" title="5. Ribbon负载均衡"></a>5. Ribbon负载均衡</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li><p>代码方式（全局）：在Order的启动类中，定义一个新的IRule：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件方式（单一）：在Order中的.yml文件中添加新的配置规则：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line"> <span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="5-1-饥饿加载"><a href="#5-1-饥饿加载" class="headerlink" title="5.1 饥饿加载"></a>5.1 饥饿加载</h4><p>Ribbon默认是懒加载，第一次访问时才会去创建<code>LoadBalanceClient</code>，请求时间会比较长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时。通过以下方式配置开启饥饿加载：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"> <span class="attr">eager-load:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开启饥饿加载</span></span><br><span class="line">  <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment"># 指定对userservice这个服务开启饥饿加载</span></span><br></pre></td></tr></table></figure><h3 id="6-Nacos注册中心"><a href="#6-Nacos注册中心" class="headerlink" title="6. Nacos注册中心"></a>6. Nacos注册中心</h3><h4 id="6-1-服务注册到Nacos"><a href="#6-1-服务注册到Nacos" class="headerlink" title="6.1 服务注册到Nacos"></a>6.1 服务注册到Nacos</h4><ul><li><p>在springcloud_demo父工程中添加spring-clloud-alibaba的管理依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注释掉user和order中原有的eureka依赖</p></li><li><p>添加nacos的客户端依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-2-服务的集群属性"><a href="#6-2-服务的集群属性" class="headerlink" title="6.2 服务的集群属性"></a>6.2 服务的集群属性</h4><ol><li><p>修改application.yml, 添加如下内容：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos server地址</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称，CD代指成都</span></span><br></pre></td></tr></table></figure></li><li><p>在Nacos控制台可看到集群变化</p><p><img src="/./Springboot%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20231102103654239.png" alt="image-20231102103654239"></p></li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/2023/10/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
      <url>/2023/10/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="热题HOT100"><a href="#热题HOT100" class="headerlink" title="热题HOT100"></a>热题HOT100</h2><h3 id="LC22括号生成"><a href="#LC22括号生成" class="headerlink" title="LC22括号生成"></a>LC22括号生成</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">&quot;((()))&quot;</span>,<span class="string">&quot;(()())&quot;</span>,<span class="string">&quot;(())()&quot;</span>,<span class="string">&quot;()(())&quot;</span>,<span class="string">&quot;()()()&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">&quot;()&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        back(n, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// n 对括号，0：左半括号数，0：右半括号数</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">back</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * n == sb.length()) &#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当左半括号小于n时，可以继续添加</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            back(n, l + <span class="number">1</span>, r);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当右边括号小于左边括号时，可以继续添加</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; l) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            back(n, l, r + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br></pre></td></tr></table></figure><h3 id="LC5最长回文子串"><a href="#LC5最长回文子串" class="headerlink" title="LC5最长回文子串"></a>LC5最长回文子串</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ans1</span> <span class="operator">=</span> palindrome(s, i, i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">ans2</span> <span class="operator">=</span> palindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">            ans = ans.length() &gt; ans1.length() ? ans : ans1;</span><br><span class="line">            ans = ans.length() &gt; ans2.length() ? ans : ans2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">palindrome</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(l + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br></pre></td></tr></table></figure><h3 id="LC3无重复字符的最长子串"><a href="#LC3无重复字符的最长子串" class="headerlink" title="LC3无重复字符的最长子串"></a>LC3无重复字符的最长子串</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">while</span> (map.get(c) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                map.put(d, map.get(d) - <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.length() &gt; right - left ? ans : s.substring(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        <span class="keyword">return</span> ans.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br></pre></td></tr></table></figure><h3 id="LC76最小覆盖子串"><a href="#LC76最小覆盖子串" class="headerlink" title="LC76最小覆盖子串"></a>LC76最小覆盖子串</h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br><span class="line">解释：最小覆盖子串 <span class="string">&quot;BANC&quot;</span> 包含来自字符串 t 的 <span class="string">&#x27;A&#x27;</span>、<span class="string">&#x27;B&#x27;</span> 和 <span class="string">&#x27;C&#x27;</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;a&quot;</span>, t = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br><span class="line">解释: t 中两个字符 <span class="string">&#x27;a&#x27;</span> 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>解法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] window = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            window[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, len = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (window[s.charAt(right)] &gt; <span class="number">0</span>) count--;</span><br><span class="line">            window[s.charAt(right)]--;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = right - left + <span class="number">1</span>;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                window[s.charAt(left)]++;</span><br><span class="line">                <span class="keyword">if</span> (window[s.charAt(left)] &gt; <span class="number">0</span>) count++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br></pre></td></tr></table></figure><h3 id="LC42接雨水"><a href="#LC42接雨水" class="headerlink" title="LC42接雨水"></a>LC42接雨水</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="/./%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/image-20231022111018869.png" alt="image-20231022111018869"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：height = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：height = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p><strong>解法：</strong>找到最左边最高的，和最右边最高的，能接住雨水的由最低的决定，则min(r_max, l_max) - 当前位置的高度，就是所接的雨水</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> [] l_max= <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> [] r_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        r_max[n-<span class="number">1</span>] = height[n-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 左边高的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            l_max[i] = Math.max(l_max[i-<span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右边高的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            r_max[i] = Math.max(r_max[i+<span class="number">1</span>],height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 计算每个位置的雨水</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum += Math.min(l_max[i], r_max[i]) -height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br></pre></td></tr></table></figure><h3 id="LC11盛最多水的容器"><a href="#LC11盛最多水的容器" class="headerlink" title="LC11盛最多水的容器"></a>LC11盛最多水的容器</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="/./%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/image-20231023100947315.png" alt="image-20231023100947315"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：height = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= height[i] &lt;= 10^4</code></li></ul><p><strong>解法：</strong>双指针，盛水由最短的决定，找左右两边最短的乘以距离就是面积，收缩区间，小的那边往内收缩</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minH</span> <span class="operator">=</span> Math.min(height[l],height[r]);</span><br><span class="line">            ans = Math.max(ans, minH * (r - l));</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口幂等性，在项目中怎么保证幂等性</title>
      <link href="/2023/10/08/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/"/>
      <url>/2023/10/08/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>学习幂等性，了解什么是幂等性，以及在项目中有哪些方法可以保证幂等性。</p><h3 id="1-什么是幂等性？"><a href="#1-什么是幂等性？" class="headerlink" title="1. 什么是幂等性？"></a>1. 什么是幂等性？</h3><p>幂等性是指无论操作执行多少次，结果都是相同的</p><h3 id="2-什么是接口幂等性？"><a href="#2-什么是接口幂等性？" class="headerlink" title="2. 什么是接口幂等性？"></a>2. 什么是接口幂等性？</h3><p>指的是一个接口，使用<strong>相同参数</strong>重复执行的情况下，对数据造成的改变只发生一次，应用场景：前端未设置多次点击误触、多次点击付款等操作</p><h3 id="3-可能发生的场景"><a href="#3-可能发生的场景" class="headerlink" title="3. 可能发生的场景"></a>3. 可能发生的场景</h3><p>在分布式框架中，存在网络通信，一个请求除了成功或失败以外，还额外多了一个<strong>未知</strong>状态。</p><p>即：如果一次远程接口调用失败，有可能这个请求在服务端已经被执行，但是客户端并没得到执行结果，客户端为了确保这个请求执行成功，可能会发起重试请求的操作，这就会导致一个接口被重复调用。</p><p>以上则需要在服务端的接口中取识别当前请求是否是重试请求，从而不再进行数据的变更操作。</p><h3 id="4-常见的解决方案如下"><a href="#4-常见的解决方案如下" class="headerlink" title="4. 常见的解决方案如下"></a>4. 常见的解决方案如下</h3><ul><li><p><strong>数据库唯一索引：</strong>专门创建一个请求消息表，请求消息设为<strong>唯一索引</strong>，每次收到请求消息后生成MD5值插入到请求消息表中，只要出现重复的，抛出异常，可以捕获异常来避免重复对数据变更。</p><blockquote><p>MD5：是一种密码散列函数，可以将任意长度的数据映射到一个固定长度的散列值，通常以32位的十六进制数表示。</p><ul><li>使用MD5可以节省空间</li><li>可以提高效率</li><li>可以保护隐私</li><li>可以防止重复</li></ul></blockquote></li><li><p><strong>使用Redis的setNx：</strong>将请求消息中带有唯一标识的信息存到Redis里面，根据setNx命令返回的结果来判断是否重复执行，如果返回0，则表示请求是重复的，可以丢弃该请求。</p></li><li><p><strong>使用状态机的方式：</strong>让每次操作使系统从一个状态转移到另外一个状态，因为状态只会前进不会后退，即使状态被重复执行，系统的最终状态也不会被改变。</p><blockquote><p>状态机：表示系统总是处于某种状态，任何给定的时间点，只能处于一种状态，当某个事件或者条件发生时，系统会从一个状态转移到另一个状态，且不会后退。</p></blockquote></li></ul><p><strong>举例说明：例如，有一个购物系统，其中包括四种状态（未付款、已付款、已发货、已收货），当用户完成付款后，会从“未付款”状态转移到“已付款”状态。即使用户不小心多次点击“付款”按钮，系统也不会再从“未付款”状态转移到“已付款”状态，因为它已经处于“已付款”状态，从而实现系统的幂等性</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2023/09/23/Java%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/09/23/Java%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a><code>Java面试</code></h1><h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a><code>一、基础</code></h2><h3 id="1-面向对象编程有哪些特征"><a href="#1-面向对象编程有哪些特征" class="headerlink" title="1. 面向对象编程有哪些特征?"></a><code>1. 面向对象编程有哪些特征?</code></h3><p><strong>抽象：</strong>抽象是对同一个目标的共有的属性（特征）和方法（功能&#x2F;行为）进行抽取、归纳、总结。所以抽象不是了解和解决全部问题，而是选择公共部分，忽略一个主题中与当前目标无关的那些方面。</p><p><strong>封装：</strong>封装就是隐藏对象的属性和实施细节，控制成员属性的访问和修改权限，通过特定公开的方法暴露给外面访问。比如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Yangyong test&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name属性被封装起来，只能通过对象的<code>getName()</code>方法才能访问。</p><p><strong>继承：</strong>继承就是指子类继承父类的成员和方法，使得子类也能具有父类相同的行为。 </p><blockquote><p>&#x3D;&#x3D;Java类之间只能实现单继承，接口之间可以实现多继承&#x3D;&#x3D;</p></blockquote><p><strong>多态：</strong>多态是指同一个行为具有多个不同的表现形式或形态，如一个类的方法在不同的情况有不同的表现形式。</p><blockquote><p>&#x3D;&#x3D;比如方法重写：子类可以重写父类的方法，通过父类引用变量调用该方法时，根据实际对象的类型，会调用子类中的方法。&#x3D;&#x3D;</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">father</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">father</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">father</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son1</span>();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son2</span>();</span><br><span class="line">        f1.father;</span><br><span class="line">        f2.father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-JDK-和JRE的区别是什么？"><a href="#2-JDK-和JRE的区别是什么？" class="headerlink" title="2. JDK 和JRE的区别是什么？"></a><code>2. JDK 和JRE的区别是什么？</code></h3><p><strong>JDK：</strong>JDK全称：Java Development Kit，是整个Java的核心，包含Java运行环境（JRE）和一系列Java开发工具完整的包。</p><p><strong>JRE：</strong>JRE全称Java Runtime Environment，是Java程序的运行环境，包含JVM、Java核心库等。JRE只能用于运行Java程序，不能用于编译Java程序。JRE是JDK的子集。</p><p><img src="/2023/09/23/Java%E9%9D%A2%E8%AF%95/JavaCode\Java学习书籍\images\JDK.jpg"></p><h3 id="3-如何编译和运行Java文件"><a href="#3-如何编译和运行Java文件" class="headerlink" title="3. 如何编译和运行Java文件"></a><code>3. 如何编译和运行Java文件</code></h3><p>使用<code>javac</code>命令来编译.java文件</p><blockquote><p><code>javac</code> Test.java</p></blockquote><p>使用<code>java</code>命令来运行</p><blockquote><p><code>java</code>Test</p></blockquote><h3 id="4-Java中的关键字有哪些？"><a href="#4-Java中的关键字有哪些？" class="headerlink" title="4. Java中的关键字有哪些？"></a><code>4. Java中的关键字有哪些？</code></h3><table><thead><tr><th>关键字</th><th>含义</th><th>关键字</th><th>含义</th><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>package</td><td>指定包名</td><td>import</td><td>引用类</td><td>class</td><td>定义类</td></tr><tr><td>interface</td><td>接口定义</td><td>abstract</td><td>抽象类或抽象方法</td><td>new</td><td>创建对象</td></tr><tr><td>this</td><td>实例本身</td><td>super</td><td>引用父类</td><td>void</td><td>无返回</td></tr><tr><td>byte</td><td>字节型</td><td>int</td><td>整型</td><td>short</td><td>短整型</td></tr><tr><td>long</td><td>长整型</td><td>float</td><td>单精度浮点数</td><td>double</td><td>双精度浮点数</td></tr><tr><td>boolean</td><td>布尔型</td><td>enum</td><td>枚举型</td><td>extends</td><td>继承类</td></tr><tr><td>implements</td><td>实现接口</td><td>private</td><td>私有权限，本类可用</td><td>protected</td><td>保护权限，本包、本类和子类可用</td></tr><tr><td>public</td><td>公开权限，可跨包使用</td><td>final</td><td>类不可继承、方法不可重写、常量</td><td>static</td><td>静态属性</td></tr><tr><td>synchronized</td><td>线程同步</td><td>if</td><td>如果</td><td>else</td><td>或者</td></tr><tr><td>for</td><td>for循环</td><td>do</td><td>do while循环</td><td>switch case default</td><td>分支</td></tr><tr><td>break</td><td>结束循环</td><td>continue</td><td>继续循环</td><td>return</td><td>返回</td></tr><tr><td>try</td><td>异常代码捕获</td><td>catch</td><td>异常处理</td><td>finally</td><td>最后异常处理</td></tr><tr><td>throw</td><td>手动抛出一个异常</td><td>throws</td><td>声明要抛出的异常</td><td>instanceof</td><td>判断是否XX类的实例</td></tr><tr><td>volatile</td><td>线程可见</td><td>transient</td><td>不用序列化</td><td>assert</td><td>断言</td></tr></tbody></table><p>保留关键字：goto 跳转   const 常量</p><p>特殊关键字：true false null</p><h3 id="5-Java-中常量类型有几种类型？"><a href="#5-Java-中常量类型有几种类型？" class="headerlink" title="5. Java 中常量类型有几种类型？"></a><code>5. Java 中常量类型有几种类型？</code></h3><p>Java常量有三种类型：静态常量（类中）、成员常量（类中）、局部常量（类方法中）</p><h3 id="6-Java中有哪几种基本数据类型？"><a href="#6-Java中有哪几种基本数据类型？" class="headerlink" title="6. Java中有哪几种基本数据类型？"></a><code>6. Java中有哪几种基本数据类型？</code></h3><p><strong>整型：</strong>byte（1）、short（2）、int（4）、long（8）</p><p><strong>浮点型：</strong>float（4）、double（8）</p><p><strong>字符型：</strong>char（2）</p><p><strong>布尔型：</strong><code>boolean</code></p><h3 id="7-和equals的区别"><a href="#7-和equals的区别" class="headerlink" title="7. ==和equals的区别"></a><code>7. ==和equals的区别</code></h3><p><strong>&#x3D;&#x3D;：</strong> 1）如果比较的对象是基本数据类型，则比较的是数值是否相同；</p><p>​         2）如果比较的是引用数据类型，则比较的是对象地址是否相同。</p><p><strong><code>equals</code>：</strong><code>Object</code>类提供的方法，就收<code>Object</code>参数类型，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于比较两个对象是否相等，默认是比较两个对象的地址，不能用于比较基本数据类型，但可以是包装类型。</p><h3 id="8-String-比较使用-还是equals？为什么？"><a href="#8-String-比较使用-还是equals？为什么？" class="headerlink" title="8. String 比较使用== 还是equals？为什么？"></a><code>8. String 比较使用== 还是equals？为什么？</code></h3><p>String源码中已经重写了equals方法，方法中，先用&#x3D;&#x3D;比较是否是相同的对象，然后比较内容是否相同。</p><p>&#x3D;&#x3D;所以如果要比较字符串对象的内容是否相同就用equals方法，而要比较字符串的内存地址是否相等，就用<code>==</code>比较。不过实际情况都是比较字符串内容。&#x3D;&#x3D;</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-public、private、protected和默认的区别"><a href="#9-public、private、protected和默认的区别" class="headerlink" title="9. public、private、protected和默认的区别"></a><code>9. public、private、protected和默认的区别</code></h3><table><thead><tr><th>作用域</th><th>当前类</th><th>当前包</th><th>子孙类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>默认</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><h3 id="10-s-s-1-和-s-1的区别？"><a href="#10-s-s-1-和-s-1的区别？" class="headerlink" title="10. s = s + 1 和 s += 1的区别？"></a><code>10. s = s + 1 和 s += 1的区别？</code></h3><p>如果s原有数据类型小于int类型，则<code>s = s+1</code>会发生编译异常，需要进行强制转换。而&#x3D;&#x3D;<code>s += 1</code>&#x3D;&#x3D;支持隐式强制类型转换。</p><h3 id="11-float-1-8有错吗？"><a href="#11-float-1-8有错吗？" class="headerlink" title="11. float = 1.8有错吗？"></a><code>11. float = 1.8有错吗？</code></h3><p>&#x3D;&#x3D;有错&#x3D;&#x3D;，1.8默认为双精度，需要向下转型，即&#x3D;&#x3D;<code>float = 1.8F</code>&#x3D;&#x3D;或&#x3D;&#x3D;<code>float = （float）1.8</code>&#x3D;&#x3D;。</p><h3 id="12-怎么理解值传递和引用传递？"><a href="#12-怎么理解值传递和引用传递？" class="headerlink" title="12. 怎么理解值传递和引用传递？"></a><code>12. 怎么理解值传递和引用传递？</code></h3><p><strong>值传递：</strong>传递的是基本数据类型参数的字面量值的拷贝，方法对参数的修改不会影响之前参数的值。</p><p><strong>引用传递：</strong>传递的是该参量所引用的对象在堆中地址的拷贝，而不是拷贝整个对象本身，方法对参数的修改会直接影响参数之前的值。</p><h3 id="13-static关键字有什么用？"><a href="#13-static关键字有什么用？" class="headerlink" title="13. static关键字有什么用？"></a><code>13. static关键字有什么用？</code></h3><p><code>static</code>可以用来修饰&#x3D;&#x3D;静态内部类&#x3D;&#x3D;、&#x3D;&#x3D;静态方法&#x3D;&#x3D;、&#x3D;&#x3D;静态变量&#x3D;&#x3D;、&#x3D;&#x3D;静态代码块&#x3D;&#x3D;。</p><ul><li><p>静态内部类：可以不依赖外部类实例化对象而被实例化，而普通内部类需要依靠外部类实例化后才能被实例化。如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">t1</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t11</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;普通内部类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">st</span>&#123;</span><br><span class="line">        <span class="comment">// static内部类中的方法必须是static方法，否则内部类也必须实例化。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">st1</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;static 内部类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// static内部类直接调用</span></span><br><span class="line">        test.st.st1();</span><br><span class="line">        <span class="comment">// 普通内部类首先实例化外部类，在实例化内部类才能调用内部类中的方法。</span></span><br><span class="line">        test.<span class="type">t1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>().<span class="keyword">new</span> <span class="title class_">t1</span>();</span><br><span class="line">        t1.t11();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态方法：静态方法属于类方法，不需要实例化对象就能调用。</p></li><li><p>静态变量：静态变量属于类，不需要实例化对象就可以调用。</p></li><li><p>静态代码块：静态代码块只会在类加载的时候被加载一次，有且只有一次。</p></li></ul><h3 id="14-static变量和普通变量的区别"><a href="#14-static变量和普通变量的区别" class="headerlink" title="14. static变量和普通变量的区别"></a><code>14. static变量和普通变量的区别</code></h3><ol><li>&#x3D;&#x3D;所属目标不同&#x3D;&#x3D;：static变量属于类，普通变量属于对象。</li><li>&#x3D;&#x3D;存储区域不同&#x3D;&#x3D;：static存储在静态区，普通变量存储在堆区。<strong>在java7以上，static变量存储在Class对象中，Class对象和普通对象都存在堆中。</strong></li><li>&#x3D;&#x3D;加载时间不同&#x3D;&#x3D;：static变量在类加载的时候加载，类消失而消失，普通变量在对象加载而加载，对象消失而消失。</li><li>&#x3D;&#x3D;调用方式不同&#x3D;&#x3D;：static变量通过类名或者对象调用，普通变量需要实例化对象后调用。</li></ol><h3 id="15-static方法中可不可以使用this和super？"><a href="#15-static方法中可不可以使用this和super？" class="headerlink" title="15. static方法中可不可以使用this和super？"></a><code>15. static方法中可不可以使用this和super？</code></h3><p>不可以使用。因为this和super是代表的是实例化后的操作对象，而static属于类级别，无法指代任何实例对象。</p><h3 id="16-重载和重写有什么区别？"><a href="#16-重载和重写有什么区别？" class="headerlink" title="16. 重载和重写有什么区别？"></a><code>16. 重载和重写有什么区别？</code></h3><p><strong>重写：</strong>是父类与子类之间多态性的一种表现，即子类可以覆盖从父类继承的方法。</p><p><strong>重载：</strong>一个类中方法多态性的一种表现，即一个类中可以有多个同名的方法，方法的参数类型不同，参数个数不同，返回类型也可以不相同。</p><h3 id="16-静态方法可以被继承吗？"><a href="#16-静态方法可以被继承吗？" class="headerlink" title="16. 静态方法可以被继承吗？"></a><code>16. 静态方法可以被继承吗？</code></h3><ul><li>父类的静态属性、静态方法可以被子类继承；</li><li>如果子类也定义了相同的静态方法和静态属性，父类相同的方法和属性会被隐藏。</li></ul><h3 id="17-Java的异常类有哪些？"><a href="#17-Java的异常类有哪些？" class="headerlink" title="17. Java的异常类有哪些？"></a><code>17. Java的异常类有哪些？</code></h3><p><strong>&#x3D;&#x3D;红色区域的异常表示是程序需要显示捕捉或者抛出的&#x3D;&#x3D;</strong></p><p><img src="/2023/09/23/Java%E9%9D%A2%E8%AF%95/JavaCode\Java学习书籍\images\Exception.jpg"></p><p><strong>Throwable：</strong>是Java异常类的顶级类，所有的异常类都继承这个类，**<code>Error</code><strong>和</strong><code>Exception</code>**是异常类的两大分类。</p><p><strong>Error：</strong>是非程序异常，即程序不能捕获的异常，一般是编译或者系统性错误，如**<code>OutOfMemorry</code>**内存溢出异常等。</p><p><strong>Runtime Exception：</strong>运行时异常，Java编译器不会去检查它，及时没有try-catch和throws捕获或者抛出它，也会编译通过，但是运行不通过，常见的有**<code>NullPointException</code><strong>、</strong><code>ArrayIndexOutOfBoundsException</code><strong>、</strong><code>ArithmeticException</code>**等。</p><p><strong>非运行时异常：</strong>必须通过异常处理，try-catch 或 throws 捕获或抛出，如常见的**<code>IOException</code><strong>、</strong><code>ClassNotFoundException</code><strong>、</strong><code>FileNotFoundException</code>**等。</p><h3 id="18-什么时候会发生空指针异常？"><a href="#18-什么时候会发生空指针异常？" class="headerlink" title="18. 什么时候会发生空指针异常？"></a><code>18. 什么时候会发生空指针异常？</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 该对象未进行初始化操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> obj.toString();</span><br></pre></td></tr></table></figure><h3 id="19-如何避免空指针异常"><a href="#19-如何避免空指针异常" class="headerlink" title="19. 如何避免空指针异常"></a><code>19. 如何避免空指针异常</code></h3><ol><li><p>字符串比较，常量放在前面，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(status.equals(SUCCESS))&#123;&#125;<span class="comment">// 此时status可能为null造成空指针异常，应该把常量放在前面，就能避免空指针异常。</span></span><br></pre></td></tr></table></figure></li><li><p>初始化默认值，在对象初始化的时候给它一个默认值或者默认构造实现，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> user.EMPTY;</span><br></pre></td></tr></table></figure></li><li><p>返回空集合，返回一个集合的话，默认是null，统一规范返回一个空集合，如“</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List <span class="title function_">getUserList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> userMapper.getUserList();</span><br><span class="line">    <span class="keyword">return</span> list == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">ArrayList</span>() : list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>断言，可用来检查程序的安全性，在使用之前进行条件检查，如果不符合就报异常，符合就继续。Java中自带断言关键字：assert，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">assert</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span> : <span class="string">&quot;姓名不能为空&quot;</span>;</span><br><span class="line"><span class="comment">// Spring中用法</span></span><br><span class="line">Assert.notNull(name, <span class="string">&quot;姓名不能为空&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="20-int-和-Integer-有什么区别？"><a href="#20-int-和-Integer-有什么区别？" class="headerlink" title="20. int 和 Integer 有什么区别？"></a><code>20. int 和 Integer 有什么区别？</code></h3><ul><li><strong><code>int</code></strong> 是基本数据类型，**<code>Integer</code><strong>是</strong><code>int</code>**的包装类型。</li><li>**<code>int</code><strong>的默认值是0，</strong><code>Integer</code>**属于Java类，默认值是null。</li><li>**<code>int</code><strong>可以直接使用，</strong><code>Integer</code>**必须实例化之后才能使用。</li><li>**<code>Integer</code><strong>属于Java类，所以比</strong><code>int</code><strong>应用更为广泛，比如泛型，</strong><code>int</code>**就不能。</li></ul><h3 id="21-什么是自动装箱、拆箱？"><a href="#21-什么是自动装箱、拆箱？" class="headerlink" title="21. 什么是自动装箱、拆箱？"></a><code>21. 什么是自动装箱、拆箱？</code></h3><p>自动装箱和拆箱机制提供基本数据类型和包装类型的相互装换操作。</p><p><strong>自动装箱：</strong>即把基本数据类型装换成包装类型，如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>); <span class="comment">// Java 9+ 已经废除</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">3</span>);<span class="comment">// 自动装箱其实就是调用包装类的valueOf()方法。</span></span><br><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p><strong>自动拆箱：</strong>即把包装类型转为基本数据类型，与自动装箱相反，如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>); <span class="comment">// Java 9+ 已经废除</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">3</span>);<span class="comment">// 自动装箱其实就是调用包装类的valueOf()方法。</span></span><br><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> i3;</span><br><span class="line"><span class="type">int</span> <span class="variable">i5</span> <span class="operator">=</span> i3.intValue();</span><br></pre></td></tr></table></figure><h3 id="22-StringBuffer-和StringBuilder的区别？"><a href="#22-StringBuffer-和StringBuilder的区别？" class="headerlink" title="22. StringBuffer 和StringBuilder的区别？"></a><code>22. StringBuffer 和StringBuilder的区别？</code></h3><p>都继承了<code>AbstractStringBuilder</code>，默认容量都是16个字符，扩容大小都是原来的2倍+2字符。源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;<span class="built_in">super</span>(<span class="number">16</span>);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;<span class="built_in">super</span>(<span class="number">16</span>);&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    ? hugeCapacity(minCapacity)</span><br><span class="line">         : newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全：</strong><code>StringBuffer</code>线程安全，<code>StringBuilder</code>线程不安全，前者公开的方法都用<code>synchronized</code>进行修饰。</p><p><strong>缓冲区：</strong><code>StringBuffer</code>每次获取<code>toString</code>都会去缓存区的<code>toStringCache</code>构造一个字符串，而<code>StringBuilder</code>每次都需要复制一次字符串，在构造一个字符串。</p><p><strong>性能：</strong><code>StringBuilder</code>性能要比<code>StringBuffer</code>要好得多，因为没有加锁。</p><h3 id="23-普通类和抽象类的区别"><a href="#23-普通类和抽象类的区别" class="headerlink" title="23. 普通类和抽象类的区别"></a><code>23. 普通类和抽象类的区别</code></h3><ul><li>抽象类必须用abstract关键字标识，普通类不用。</li><li>抽象类可包含抽象方法，抽象方法不在抽象类中实现。普通类中不能包含抽象方法。</li><li>抽象类设计给子类继承用的，不能直接通过new实例化，只能通过子类继承来实例化，或者通过匿名内部类进行实例化。普通类可以直接实例化。</li></ul><h3 id="24-静态变量和实例变量有什么区别"><a href="#24-静态变量和实例变量有什么区别" class="headerlink" title="24. 静态变量和实例变量有什么区别?"></a><code>24. 静态变量和实例变量有什么区别?</code></h3><p><strong>静态变量：</strong>属于类，不属于任何一个对象，当前类不管创建多个对象，只有一个静态变量被多个对象共享。</p><p><strong>实例变量：</strong>属于某一个对象，需要通过一个类的对象实例才能访问它。</p><h3 id="25-接口和抽象类有什么区别？"><a href="#25-接口和抽象类有什么区别？" class="headerlink" title="25. 接口和抽象类有什么区别？"></a><code>25. 接口和抽象类有什么区别？</code></h3><ol><li>抽象类是一个”类”，接口只是一个”接口”。</li><li>抽象类可以写构造方法，接口不能写构造方法，即抽象类参与类的实例化过程，接口则不是。</li><li>抽象类可以有自己的各种成员变量，可以通过类中非抽象方法进行修改；接口中的变量默认是<code>public static final</code>修饰的，都是常量，不能被自己或者外部修改。</li><li>接口实现多继承，而抽象类只能单继承。类与类是单继承，类与接口、接口与接口可以多继承。</li></ol><h3 id="26-除了用new关键字创建对象，还有哪些？"><a href="#26-除了用new关键字创建对象，还有哪些？" class="headerlink" title="26. 除了用new关键字创建对象，还有哪些？"></a><code>26. 除了用new关键字创建对象，还有哪些？</code></h3><p>&#x3D;&#x3D;克隆一个对象&#x3D;&#x3D;</p><p>对象类需要实现Cloneable接口，并实现clone()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrilFriend</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在克隆一个对象，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">girlFriend1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;克隆一个对象&quot;</span>);</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">girlFriend2</span> <span class="operator">=</span> (GirlFriend) girlFriend1.clone();</span><br><span class="line">        System.out.println(girlFriend2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：GirlFriend&#123;name=&#x27;克隆一个对象&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;派发一个对象（反射机制）&#x3D;&#x3D;</p><p>主要代码，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 派发一个对象</span></span><br><span class="line"><span class="type">GirlFriend</span> <span class="variable">girlFriend</span> <span class="operator">=</span> GirlFriend.class.newInstance();</span><br><span class="line">girlFriend.setName(<span class="string">&quot;派发一个对象&quot;</span>);</span><br><span class="line">System.out.println(girlFriend);</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;动态加载一个对象（反射）&#x3D;&#x3D;</p><p>主要代码，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态加载一个对象</span></span><br><span class="line"><span class="type">GirlFriend</span> <span class="variable">girlFriend3</span> <span class="operator">=</span> (GirlFriend) Class.forName(<span class="string">&quot;GirlFriend&quot;</span>).newInstance();</span><br><span class="line">girlFriend3.setName(<span class="string">&quot;动态加载一个对象&quot;</span>);</span><br><span class="line">System.out.println(girlFriend3);</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;构造一个对象（反射）&#x3D;&#x3D;</p><p>主要代码，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个对象</span></span><br><span class="line"><span class="type">GirlFriend</span> <span class="variable">g</span> <span class="operator">=</span> GrilFriend.class.getConstructor().newInstance();</span><br><span class="line">g.setName(<span class="string">&quot;构造一个对象&quot;</span>);</span><br><span class="line">System.out.println(g);</span><br></pre></td></tr></table></figure><h3 id="27-equals-和HashCode之间的区别和联系？"><a href="#27-equals-和HashCode之间的区别和联系？" class="headerlink" title="27. equals 和HashCode之间的区别和联系？"></a><code>27. equals 和HashCode之间的区别和联系？</code></h3><ol><li>两个对象用<code>equals()</code>比较返回<code>true</code>时，那么<code>hashCode()</code>方法必须返回相同的结果，如果重写<code>equals()</code>方法，也必须重写<code>hashCode()</code>方法。</li><li>两个对象用<code>equals()</code>比较返回<code>false</code>时，不要求<code>hashCode()</code>方法可以返回不同的值，但是最好返回不同的值，以提高哈希表的性能。</li></ol><h3 id="28-两个对象equals结果为true-HashCode一定相同吗？"><a href="#28-两个对象equals结果为true-HashCode一定相同吗？" class="headerlink" title="28. 两个对象equals结果为true,HashCode一定相同吗？ "></a><code>28. 两个对象equals结果为true,HashCode一定相同吗？ </code></h3><p>&#x3D;&#x3D;不一定相同,但严格意义上必须相同&#x3D;&#x3D;，如果该类没有重写<code>HashCode()</code>方法，<code>HashCode</code>就不一定相同 。</p><h3 id="29-两个对象HashCode相等，equals方法也会相等吗？"><a href="#29-两个对象HashCode相等，equals方法也会相等吗？" class="headerlink" title="29. 两个对象HashCode相等，equals方法也会相等吗？"></a><code>29. 两个对象HashCode相等，equals方法也会相等吗？</code></h3><p>不一定，两个对象<code>equals</code>相等，则它们的hashCode必须相等，反过来不需要相同。</p><p><strong>对象的hashCode可能存在冲突的情况，即多个对象共用一个hashCode，Java中是允许的，但如果重写了equals()方法，比较的是对象的值，这时，两个对象的equals比较的值就可能不相同。</strong></p><h3 id="30-为什么重写equals就要重写hashCode？"><a href="#30-为什么重写equals就要重写hashCode？" class="headerlink" title="30. 为什么重写equals就要重写hashCode？"></a><code>30. 为什么重写equals就要重写hashCode？</code></h3><p><strong>如果只重写了equals方法，没有重写hashCode方法，就会出现equals相等，hashCode不相等的情况。</strong></p><p>而<code>Hash*</code>相关的集合都是基于Hash表来实现的，比如<code>HashMap</code>数据结构是数组+链表为基础，其中关键的是数组下标的处理。而数组的索引下标是根据传入值的<code>hashCode</code>方法来决定的。</p><p><strong>在hashCode相等的情况下：</strong></p><ul><li>如果数组索引位置上已经有值了，值相等则进行覆盖，若不相等则加入到对应的链表中。</li><li>如果数组索引上没有值，直接插入。</li></ul><p>所以如果多个<code>equals</code>相等的对象，而他们的<code>hashCode</code>不相等，他们就会不断插入到数组中，而不会进行覆盖，由此会带来<code>Hash*</code>相关的集合不能正常工作。</p><h2 id="二、集合"><a href="#二、集合" class="headerlink" title="二、集合"></a>二、集合</h2><h3 id="1-常见的集合有哪些？"><a href="#1-常见的集合有哪些？" class="headerlink" title="1. 常见的集合有哪些？"></a><code>1. 常见的集合有哪些？</code></h3><p><strong>Java所有集合框架的顶级接口有两大类：<code>Collection</code>接口和<code>Map</code>接口。</strong></p><ul><li><p><code>Collection</code>接口的子接口包括<code>List</code>接口和<code>Set</code>接口；</p><p><code>List</code>接口的实现类主要有：<code>ArrayList、LinkedList、Stack、Vector...</code></p><p><code>Set</code>接口的实现类主要有：<code>TreeSet、HashSet、LinkedHashSet...</code></p></li><li><p><code>Map</code>接口的实现类主要有：<code>HashMap、TreeMap、HashTable、ConcurrentHashMap...</code></p></li></ul><h3 id="2-常见的并发集合有哪些？"><a href="#2-常见的并发集合有哪些？" class="headerlink" title="2. 常见的并发集合有哪些？"></a><code>2. 常见的并发集合有哪些？</code></h3><p><code>ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque、CopyOnWriteArrayList、CopyOnWriteArraySet...</code></p><h3 id="3-Comparable和Comparator接口的区别"><a href="#3-Comparable和Comparator接口的区别" class="headerlink" title="3. Comparable和Comparator接口的区别"></a><code>3. Comparable和Comparator接口的区别</code></h3><ul><li><code>Comparable</code>是排序接口，若类实现了<code>Comparable</code>接口，并实现排序方法，就表示该类支持排序，相当于一个内置排序器。</li><li><code>Comparator</code>是比较器接口，可以创建多个<code>Comparator</code>接口的实现来实现自定义排序，相当于一个外部排序器。</li></ul><h3 id="4-List、Set、Map之间的区别是什么？"><a href="#4-List、Set、Map之间的区别是什么？" class="headerlink" title="4. List、Set、Map之间的区别是什么？"></a><code>4. List、Set、Map之间的区别是什么？</code></h3><p>它们的区别主要体现在数据结构、元素是否有序、元素是否可重复、键值是否为null等。三个接口的思维导图如下：</p><p><img src="/2023/09/23/Java%E9%9D%A2%E8%AF%95/JavaCode\Java学习书籍\images\集合框架2.png"></p><h3 id="5-HashMap和HashTable的区别？"><a href="#5-HashMap和HashTable的区别？" class="headerlink" title="5. HashMap和HashTable的区别？"></a><code>5. HashMap和HashTable的区别？</code></h3><p>HashMap线程不安全，HashTable线程安全。</p><p>HashMap性能优于HashTable，因为HashTable加锁导致阻塞。&#x3D;&#x3D;如果保证线程安全又性能好，建议使用JUC包下的ConcurrentHashMap&#x3D;&#x3D;</p><p>HashMap的键值都可以为null，HashTable的键值不能为null，具体如源码所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashTable put()源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HashMap hash()源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 当key为空的时候进行了处理</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方式不一样，HashMap是继承AbstractMap，HashTable继承Dictionary。</p><p>容量扩容，两者的负载因子都是0.75f，HashMap的初始容量为16，扩容为原来的2倍；HashTable初始容量为11，扩容为原来的2倍+1。</p><p>迭代器不一样，HashMap中的Iterator迭代器是fail-fast的，而HashTable的Enumerator不是fail-fast的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见的排序和查找算法，持续更新中...</title>
      <link href="/2023/09/22/%E5%9F%BA%E7%A1%80%E7%AF%87-%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/09/22/%E5%9F%BA%E7%A1%80%E7%AF%87-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>二分查找、冒泡排序、选择排序、插入排序、归并排序、快排</p><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> [] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h= nums.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; h)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 位运算 int m = (h + l) &gt;&gt;&gt; 1;</span></span><br><span class="line">        <span class="keyword">if</span>(nums[m] == target) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; target) h = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &lt; target) l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原始冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="comment">// 控制冒泡次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// 控制比较次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length -<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums,j+<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为每一次冒到头的数字不需要比较，可优化比较次数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="comment">// 控制冒泡次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">     <span class="comment">// 控制比较次数，冒泡一次，比较次数少一次，搜易判断条件变为nums.length-1-i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length -<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums,j+<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在i&lt;nums.length-1这个范围内已经有序，则无需在进行冒泡，对冒泡次数进行排序。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="comment">// 控制冒泡次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> ture;</span><br><span class="line">        <span class="comment">// 控制比较次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length -<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums,j+<span class="number">1</span>,j);</span><br><span class="line">                <span class="comment">// 如果进行交换则还未有序</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后flag为true则有序不许再进行下一次的冒泡</span></span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对比较次数进行再次优化，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 控制冒泡次数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//控制比较次数</span></span><br><span class="line">        <span class="comment">// last记录最后一次比较的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums,i,i+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 最后一次比较索引为下一次比较的总次数</span></span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一次冒比较次数的总次数动态变化</span></span><br><span class="line">        n = last;</span><br><span class="line">        <span class="comment">// 当比较到数组头的时候就不在冒泡。</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> nums[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">// i表示已排好序的目标索引，即从后续未排好序中选择最小的一个元素要交换的目标索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=s+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="comment">// 选择数组中剩余部分比剩余部分第一个元素小的数据</span></span><br><span class="line">            <span class="keyword">if</span>(nums[s] &gt; nums[j])</span><br><span class="line">                s = j;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 找到最小的就进行交换，如果i一开始就是最小的 即s==i，就不交换</span></span><br><span class="line">       <span class="keyword">if</span>(s!=i)  swap(nums, s, j);</span><br><span class="line">       System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSortTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        insertSort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; <span class="comment">// 记录前一个位置下标用于后续移动</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; nums[j])&#123;</span><br><span class="line">                    nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    public void mergeSort(int[] nums, int left, int right) &#123;</span></span><br><span class="line"><span class="comment">//        if (left &lt; right) &#123;</span></span><br><span class="line"><span class="comment">//            int mid = (left + right) &gt;&gt; 1;</span></span><br><span class="line"><span class="comment">//            mergeSort(nums, left, mid);</span></span><br><span class="line"><span class="comment">//            mergeSort(nums, mid + 1, right);</span></span><br><span class="line"><span class="comment">//            merge(nums, left, mid, right);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSortByIteration</span><span class="params">(<span class="type">int</span> nums[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">stepSize</span> <span class="operator">=</span> <span class="number">1</span>; stepSize &lt; n; stepSize *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; n - stepSize; left += <span class="number">2</span> * stepSize) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + stepSize - <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.min(left + <span class="number">2</span> * stepSize - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                merge(nums, left, mid, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ln</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rn</span> <span class="operator">=</span> right - mid;</span><br><span class="line">        <span class="type">int</span>[] leftN = <span class="keyword">new</span> <span class="title class_">int</span>[ln];</span><br><span class="line">        <span class="type">int</span>[] rightN = <span class="keyword">new</span> <span class="title class_">int</span>[rn];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ln; i++) &#123;</span><br><span class="line">            leftN[i] = nums[left + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rn; i++) &#123;</span><br><span class="line">            rightN[i] = nums[mid + <span class="number">1</span> + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; ln &amp;&amp; j &lt; rn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftN[i] &lt;= rightN[j]) &#123;</span><br><span class="line">                nums[k] = leftN[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = rightN[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; ln) &#123;</span><br><span class="line">            nums[k++] = leftN[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; rn) &#123;</span><br><span class="line">            nums[k++] = rightN[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6-快排（含单边、双边快排-递归和非递归）"><a href="#6-快排（含单边、双边快排-递归和非递归）" class="headerlink" title="6. 快排（含单边、双边快排&#x2F; 递归和非递归）"></a>6. 快排（含单边、双边快排&#x2F; 递归和非递归）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        quickSort1(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort1</span><span class="params">(<span class="type">int</span> nums[])</span> &#123;</span><br><span class="line"><span class="comment">//      if (nums == null || nums.length &lt;= 1) return;</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        stack.push(nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition2(nums, l, h);</span><br><span class="line">            <span class="keyword">if</span> (p - <span class="number">1</span> &gt; l) &#123;</span><br><span class="line">                stack.push(l);</span><br><span class="line">                stack.push(p - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p + <span class="number">1</span> &lt; h) &#123;</span><br><span class="line">                stack.push(p + <span class="number">1</span>);</span><br><span class="line">                stack.push(h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, i, j);</span><br><span class="line">        quickSort2(nums, i, p - <span class="number">1</span>);</span><br><span class="line">        quickSort2(nums, p + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 单边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 取最右边的为基准点</span></span><br><span class="line">        <span class="comment">// 将nums中小于基准点的元素移到左边</span></span><br><span class="line">        <span class="comment">//  大于基准点的移到右边</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> nums[j];</span><br><span class="line">        <span class="comment">// 用双指针进行比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i; <span class="comment">// 指向被交换的下标</span></span><br><span class="line">        <span class="comment">// r：用于找到小于p的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i; r &lt; j; r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[r] &lt; p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l != r)</span><br><span class="line">                    swap(nums, l, r);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != j)</span><br><span class="line">            swap(nums, l, j);<span class="comment">// 把基准点移到中间去</span></span><br><span class="line">       System.out.println(Arrays.toString(nums) + <span class="string">&quot; 基准点 l = &quot;</span> + l);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 双边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">           <span class="comment">// 两个while不能交换顺序，因为一开始把左边的nums[i]暂存</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt;= p) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= p) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = p; <span class="comment">// 移动完后，将暂存的放到空的位置上</span></span><br><span class="line">       System.out.println(Arrays.toString(nums) + <span class="string">&quot; 基准点 l = &quot;</span> + l);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><p>堆排序是一种基于比较的排序算法，其基本思路如下：</p><ol><li><strong>构建最大堆（Max-Heapify）</strong>：将待排序的序列构造成一个最大堆，即满足父节点的值大于其子节点的值。</li><li><strong>堆顶与末尾元素交换</strong>：此时，整个序列的最大值就是堆顶的根节点。将它与堆数组的末尾元素进行交换，此时末尾就为最大值。</li><li><strong>重新调整结构</strong>：去掉末尾元素后，我们得到了一个 n-1 个元素的新序列。然后再次调整这个序列，使其继续满足最大堆的性质。</li><li><strong>重复步骤 2 和步骤 3</strong>：继续将堆顶元素与末尾元素交换，并剔除末尾元素，然后再次调整剩余元素使其满足最大堆的性质。重复这个过程，直到所有元素都排好序。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        heapSort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            help(nums, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(nums, i, <span class="number">0</span>);</span><br><span class="line">            help(nums, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">help</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> n, <span class="type">int</span> large)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> large;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span> * large + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span> * large + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[i]) i = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[i]) i = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != large) &#123;</span><br><span class="line">            swap(nums, i, large);</span><br><span class="line">            help(nums, n, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github教程</title>
      <link href="/2023/09/22/hexo+github%E6%95%99%E7%A8%8B/"/>
      <url>/2023/09/22/hexo+github%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>此教程详细介绍了hexo的安装步骤</p><h2 id="1-git-node"><a href="#1-git-node" class="headerlink" title="1. git+node"></a>1. git+node</h2><h2 id="N-hexo图片显示问题"><a href="#N-hexo图片显示问题" class="headerlink" title="N. hexo图片显示问题"></a>N. hexo图片显示问题</h2><ol><li><p>修改hexo下的_config.yml文件：</p><p>将 <code>post_asset_folder: false</code> 修改为 <code>post_asset_folder: true</code>。</p></li><li><p>安装图片路径的插件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>如果使用以下命令安装插件，则需要修改**&#x2F;node_modules&#x2F;hexo-asset-image&#x2F;index.js**：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>具体的<code>js</code>修改为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line"><span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line"><span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">    <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">        <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">        <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">            !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) &#123;</span><br><span class="line">            <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.<span class="title function_">shift</span>();</span><br><span class="line">            src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>把与<code>.md</code>同名的图片文件夹放在与<code>_posts</code>同级，目录下：</p><p><img src="/./hexo+github%E6%95%99%E7%A8%8B/image-20231026144235091.png" alt="image-20231026144235091"></p></li><li><p><code>.md</code>文件中的图片的路径为：<br><img src="/./hexo+github%E6%95%99%E7%A8%8B/image-20231026144414751.png" alt="image-20231026144414751"></p></li><li><p>为了保证本地<code>.md</code>文件中也显示图片，则在此文件夹下创建一个同名的图片文件，如下：</p><p><img src="/./hexo+github%E6%95%99%E7%A8%8B/image-20231026145351160.png" alt="image-20231026145351160"></p></li><li><p>网页就能正常显示：</p><p><img src="/./hexo+github%E6%95%99%E7%A8%8B/image-20231026145852416.png" alt="image-20231026145852416"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 八股</title>
      <link href="/2023/09/22/java%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"/>
      <url>/2023/09/22/java%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<p>主要介绍了一些Java面试过程中的八股文。</p><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="1-为什么说重入锁是粒度更小的锁？"><a href="#1-为什么说重入锁是粒度更小的锁？" class="headerlink" title="1. 为什么说重入锁是粒度更小的锁？"></a>1. 为什么说重入锁是粒度更小的锁？</h3><p><img src="/2023/09/22/java%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/Users\49882\AppData\Roaming\Typora\typora-user-images\image-20230731102326149.png" alt="image-20230731102326149"></p><h3 id="2-可重入锁代码示例"><a href="#2-可重入锁代码示例" class="headerlink" title="2. 可重入锁代码示例"></a>2. 可重入锁代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 第一次获取重入锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the lock.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 在这里执行需要保护的临界区代码</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 调用另一个方法，再次获取同一个重入锁</span></span><br><span class="line">            nestedMethod();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 第一次释放重入锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nestedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 第二次获取同一个重入锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the lock again.&quot;</span>);</span><br><span class="line">            <span class="comment">// 在这里执行需要保护的另一个临界区代码</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            thirdMethod();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 第一次释放重入锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thirdMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 第二次获取同一个重入锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the lock third.&quot;</span>);</span><br><span class="line">            <span class="comment">// 在这里执行需要保护的另一个临界区代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 第二次释放重入锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockExample</span>();</span><br><span class="line">        <span class="comment">// 创建两个线程并启动它们</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; example.performTask());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; example.performTask());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-临界区代码包括哪些？"><a href="#3-临界区代码包括哪些？" class="headerlink" title="3. 临界区代码包括哪些？"></a>3. 临界区代码包括哪些？</h3><blockquote><p>临界区代码是指那些访问共享资源的代码段，在多线程环境中需要进行互斥保护的部分。这些代码段涉及对共享资源的读写操作，因此在多线程并发执行时，如果不进行适当的同步控制，可能会导致数据不一致、竞态条件（Race Condition）等问题。</p><p>临界区代码应该满足两个条件：</p><ol><li><p>&#x3D;&#x3D;访问共享资源&#x3D;&#x3D;：临界区代码必须涉及对共享资源（如共享变量、共享对象等）的读写或修改操作。这些共享资源通常是多个线程需要共同访问的资源。</p></li><li><p>&#x3D;&#x3D;需要互斥保护&#x3D;&#x3D;：由于多个线程并发执行，如果不进行同步控制，可能会导致数据不一致或竞态条件。因此，临界区代码需要通过锁或其他同步机制来实现互斥保护，保证同一时间只有一个线程能够进入临界区执行。</p></li></ol><p>临界区代码的范围因具体情况而异，可能是几行代码，也可能是较大的代码块。一般来说，涉及对共享资源的操作的代码都应该被视为临界区代码。常见的临界区代码包括：</p><ol><li>对共享变量的读写操作。</li><li>对共享数据结构（如队列、列表、映射等）的读写操作。</li><li>对共享文件或数据库的读写操作。</li><li>对共享资源进行计算或处理的代码。</li></ol><p>在使用重入锁或其他同步机制时，需要在临界区代码的开始处获取锁，在临界区代码执行完毕后释放锁，确保同一时间只有一个线程能够进入临界区执行，从而保证多线程访问共享资源的正确性和一致性。同时，也要避免在临界区代码中阻塞时间过长，以免影响系统的吞吐量和响应性能。</p></blockquote><h3 id="4-synchronized是可重入锁吗？"><a href="#4-synchronized是可重入锁吗？" class="headerlink" title="4. synchronized是可重入锁吗？"></a>4. synchronized是可重入锁吗？</h3><p>&#x3D;&#x3D;是可重入锁&#x3D;&#x3D;，如下示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>synchronized</code>锁的不是方法，而是当前实例对象，当一个线程进入该实例对象的任意一个<code>synchronized</code>方法，即获得该对象锁，然后再调用<code>add()</code>方法，因为也是被<code>synchronized</code>修饰，所以可以直接进入。所以<code>synchronized</code>是可重入锁。</p><p>注意：</p><blockquote><p>如果多个线程分别持有不同的实例对象，那么它们之间的执行是可以并发进行的。但是，如果同一个实例对象上有多个线程调用这两个方法，由于这两个方法都锁定了当前实例对象，这会导致这两个方法不能在同一时间被并发执行，只能顺序执行，以保证线程安全。</p></blockquote><h3 id="5-以下是重入锁的性质吗？"><a href="#5-以下是重入锁的性质吗？" class="headerlink" title="5. 以下是重入锁的性质吗？"></a>5. 以下是重入锁的性质吗？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123; <span class="comment">// 获取lock1锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Outer method: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            innerMethod(); <span class="comment">// 调用内部方法，获取lock2锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123; <span class="comment">// 获取lock2锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Inner method: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; example.outerMethod(), <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;不是&#x3D;&#x3D;，因为他们获得的是不同的锁对象，在同一个线程中可以顺序执行。如果在不同线程中，可以并发执行，是相互独立的，不会相互阻塞。只有在同一个线程内部，多次获取同一个锁时，才是可重入锁。</p><h3 id="6-什么是乐观锁？"><a href="#6-什么是乐观锁？" class="headerlink" title="6. 什么是乐观锁？"></a>6. 什么是乐观锁？</h3><p>是一种用于并发控制的机制，认为在大多数情况下，并发冲突不会发生，在修改共享资源时不会立即阻塞其他线程。适用于&#x3D;&#x3D;读多写少&#x3D;&#x3D;的场景.</p><p>乐观锁常用的实现方式有两种：&#x3D;&#x3D;版本号控制&#x3D;&#x3D;、&#x3D;&#x3D;CAS操作&#x3D;&#x3D;。</p><blockquote><ol><li>版本号机制：在共享资源中引入一个版本号（或时间戳），每次对资源进行修改时，版本号都会增加。当线程要更新资源时，先读取当前版本号，完成操作后再次校验版本号是否一致，如果一致才进行更新。如果版本号不一致，说明资源已经被其他线程修改，当前线程需要重新尝试。</li><li>CAS（Compare and Swap）操作：CAS 是一种基于硬件原子性指令的乐观锁实现。CAS 操作可以判断内存中的值是否与预期值相同，如果相同则将新值写入内存，否则放弃操作。在 CAS 操作中，不需要加锁，因为它的执行是原子性的。Java 中的 <code>Atomic</code> 类使用了 CAS 操作来实现原子操作，例如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等。</li></ol></blockquote><h3 id="7-什么是悲观锁？"><a href="#7-什么是悲观锁？" class="headerlink" title="7. 什么是悲观锁？"></a>7. 什么是悲观锁？</h3><p>是一种用于并发控制的机制，认为在大多数情况下，并发冲突会发生，在修改共享资源时会立即阻塞其他线程。保证在同一时刻只有一个线程能够访问共享资源。适用于&#x3D;&#x3D;写操作较多&#x3D;&#x3D;的场景。</p><p>悲观锁常用的实现方式是使用传统的互斥锁，比如使用<code>synchronized</code>关键字、<code>ReentrantLock</code>类。</p><p>悲观锁的特点：</p><blockquote><ol><li>假设多线程之间会发生并发冲突，因此每次访问共享资源之前都会先加锁，确保只有一个线程可以访问资源。</li><li>当某个线程持有锁时，其他线程在访问同一资源时会被阻塞，直到持有锁的线程释放锁。</li><li>悲观锁会引起线程的阻塞和唤醒，因此会增加线程切换和锁竞争的开销。</li></ol></blockquote><h3 id="8-线程池的核心参数"><a href="#8-线程池的核心参数" class="headerlink" title="8. 线程池的核心参数"></a>8. 线程池的核心参数</h3><p>最大线程数、核心线程数、阻塞队列、活跃时间、拒绝策略</p><h3 id="9-线程进入线程池的步骤"><a href="#9-线程进入线程池的步骤" class="headerlink" title="9. 线程进入线程池的步骤"></a>9. 线程进入线程池的步骤</h3><p>首先判断核心线程数是否满了，没满，创建线程执行任务，满了，进入下一步，判断阻塞队列是否满了，没满，加入到队列中，满了，进行下一步，判断最大线程数是否满了，没满，创建额外线程，执行任务，判断额外线程是否超过活跃时间，是，则销毁额外线程，满了，执行拒绝策略。</p><h3 id="10-线程池的拒绝策略有哪些？"><a href="#10-线程池的拒绝策略有哪些？" class="headerlink" title="10. 线程池的拒绝策略有哪些？"></a>10. 线程池的拒绝策略有哪些？</h3><p><code>AbortPolicy</code>：直接抛弃当前任务，并抛出异常。</p><p><code>CallerRunsPolicy</code>：只用调用者所处的当前线程来处理任务</p><p><code>DisCardOldestPolicy</code>：丢弃等待队列中最旧的任务，并执行当前任务</p><p><code>DisCardPolicy</code>：直接丢弃当前任务，不抛出异常</p><h3 id="11-使用线程池的好处"><a href="#11-使用线程池的好处" class="headerlink" title="11. 使用线程池的好处"></a>11. 使用线程池的好处</h3><p>如果不使用线程池的话，通过<code>new thread.start()</code>方式可以穿件并运行一个线程，当线程数很少的时候是没有问题，但是实际环境下会开启多个线程让系统达到最高使用率，这样每次创建和销毁线程的时候会消耗大量的系统资源。</p><p>所以，有了线程池可以&#x3D;&#x3D;减少线程创建和销毁的开销&#x3D;&#x3D;、通过限制执行的线程数量来&#x3D;&#x3D;控制并发线程数量&#x3D;&#x3D;、线程池中的线程可以被多个任务重复使用保证了&#x3D;&#x3D;线程复用&#x3D;&#x3D;、可以对线程进行&#x3D;&#x3D;统一管理&#x3D;&#x3D;、还具有一定的&#x3D;&#x3D;可调整性&#x3D;&#x3D;，可以通过设置线程池的参数来调整线程数量，等待队列大小等，以适用于不同的业务负载和系统需求、线程池还可以通过限制线程数量和合理的调度来&#x3D;&#x3D;避免过多的资源竞争&#x3D;&#x3D;。</p><h3 id="12-什么是-缓存穿透"><a href="#12-什么是-缓存穿透" class="headerlink" title="12. 什么是&#x3D;&#x3D;缓存穿透&#x3D;&#x3D;"></a>12. 什么是&#x3D;&#x3D;缓存穿透&#x3D;&#x3D;</h3><p>指在高并发的场景下，当某个请求未在缓存中找到请求数据，导致请求穿透缓存，直接访问后端数据库。</p><p>&#x3D;&#x3D;解决方案：&#x3D;&#x3D;</p><ol><li><p>使用布隆过滤器：布隆过滤器是一种高效的数据结构，能够快速地判断某个数据是否存在缓存中，避免不存在的数据进行数据库查询。</p><blockquote><p>布隆过滤器是利用位数组和多个哈希函数来实现的。</p><p>初始化，创建一个位数组，所有位都为0</p><p>添加元素，通过多个哈希函数对元素进行多次哈希，根据得到的哈希值，在位数组对应的位置设置为1</p><p>查询元素，对需要查询的数据使用同样的哈希函数进行多次哈希，根据得到的哈希值，去检查位数组对应的位置是否为1,（可能存在误判）</p></blockquote></li><li><p>缓存空对象：当查询数据库结果为空时，将这个空结果缓存起来，设置一个较短的过期时间。后面从库来更新缓存</p></li></ol><h3 id="11-什么是缓存雪崩"><a href="#11-什么是缓存雪崩" class="headerlink" title="11. 什么是缓存雪崩"></a>11. 什么是缓存雪崩</h3><p>缓存的问题，缓存中大量的缓存数据大面积失效，导致大量的请求直接访问数据库，数据库负载剧增，导致系统崩溃。</p><p>&#x3D;&#x3D;解决方案：&#x3D;&#x3D; 集群</p><ol><li>引入随机过期时间，防止大量缓存数据在同一时间失效。</li><li>使用缓存集群，一个节点的缓存失效，其他缓存可以替代。</li><li>限流降级，在缓存失效的时候，对请求进行限流或者降级处理，以免大量请求同时涌入数据库。</li></ol><h3 id="12-什么是缓存击穿"><a href="#12-什么是缓存击穿" class="headerlink" title="12. 什么是缓存击穿"></a>12. 什么是缓存击穿</h3><p>指某一个特定的热点缓存数据失效，导致大量的请求打在数据库上，造成数据库的负载剧增。</p><p>&#x3D;&#x3D;解决方案：&#x3D;&#x3D;</p><ol><li><p>使用互斥锁，当一个请求发现某个热点数据的缓存失效时，使用互斥锁防止多个线程同时去访问数据库，只有得到锁的线程去访问数据库，同时更新缓存，其他线程就从缓存中获取数据。</p></li><li><p>使用分布式锁，可以避免多个节点同时加载缓存数据，保证只有一个节点可以获取并更新数据，其他节点等待。</p></li><li><p>使用二级缓存，一级缓存作为内存缓存，二级缓存用分布式缓存，当一级缓存失效的时候，就从二级缓存获取数据，减少数据库查询。</p><blockquote><p>为了防止分布式缓存同时失效，为其设置不同的过期时间，或者使用缓存预热策略，失效之前去预先加载热点数据。</p></blockquote></li><li><p>使用布隆过滤器，判断某个数据是否在缓存中，从而避免无效的数据查询，如果不在，直接返回缓存未命中。</p></li></ol><h3 id="13-Spring解决循环依赖"><a href="#13-Spring解决循环依赖" class="headerlink" title="13. Spring解决循环依赖"></a>13. Spring解决循环依赖</h3><p>&#x3D;&#x3D;使用三级缓存，举一个例子&#x3D;&#x3D;</p><ul><li>在创建一个单例Bean的时候，其过程是 实例化-&gt;设置属性-&gt;初始化，循环依赖的发生主要发生在第二步设置属性。</li><li>首先实例化A的时候，会将A的实例化暴露在三级缓存中。</li><li>然后对A进行设置属性，发现A的属性依赖于未初始化的B。</li><li>开始实例化B，将B的实例放到三级缓存中。</li><li>然后对B设置属性，发现依赖A，就去一二三级缓存中找A，在三级缓存中找到A，然后将A存到二级缓存中，同时删除三级缓存中的A实例。</li><li>B设置属性A之后，完成初始化，就把B放到一级缓存中。</li><li>然后继续对A进行设置属性，从一级缓存中找到B，完成初始化，将A放到一级缓存中，再删除二级缓存中的A。</li><li>最后，A、B都完成初始化，且都存在于一级缓存中。</li></ul><h3 id="14-Synchronized和Lock的区别"><a href="#14-Synchronized和Lock的区别" class="headerlink" title="14. Synchronized和Lock的区别"></a>14. Synchronized和Lock的区别</h3><ul><li><p>Synchronized 是内置的Java关键字；Lock是一个Java类</p></li><li><p>Synchronized 无法判断锁的状态；Lock可以判断锁的状态</p><blockquote><p>tryLock() 、lock()、lockInterruptibly()</p></blockquote></li><li><p>Synchronized 会自动释放锁；Lock需要手动释放锁，如果不释放，会造成死锁</p><blockquote><p>造成死锁的四个条件：循环等待、保持请求、互斥使用、不可抢占</p><p>解除死锁：按顺序申请资源、一次性给线程所有资源、无法破坏、主动放弃</p></blockquote></li><li><p>Synchronized 中线程1获得锁，阻塞、线程2一直等待；Lock不一定一直等下去</p></li><li><p>Synchronized 可重入，不可中断；Lock 可重入锁，可以自己设置公平和非公平锁</p></li><li><p>Synchronized 适合锁少量的代码同步问题；Lock适合锁大量的同步代码</p></li></ul><h3 id="15-sleep-和wait-的区别"><a href="#15-sleep-和wait-的区别" class="headerlink" title="15. sleep() 和wait()的区别"></a>15. sleep() 和wait()的区别</h3><ul><li>sleep() 是Thread类的方法; wait()是Object类的方法</li><li>sleep() 不会释放锁资源; wait()会释放所有同步锁</li><li>sleep() 可以在任何地方使用; wait()只能在同步方法和同步块中使用</li><li>sleep() 可以在指定时间被自动唤醒; wait()必须通过同一对象来唤醒</li><li>sleep() 主要用于当前线程的休眠; wait() 主要用于多线程之间的通信</li></ul><h3 id="16-start-和run-的区别"><a href="#16-start-和run-的区别" class="headerlink" title="16. start()和run()的区别"></a>16. start()和run()的区别</h3><ul><li>start()是重新开启一个线程，再调用run()方法来执行；而run()方法是在同一个线程中执行任务</li><li>start()只能执行一次；而run()可以执行多次</li><li>start()不需要等待run()中方法执行完，在执行其他方法；run()只能执行完才能执行其他方法</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-ISO分层"><a href="#1-ISO分层" class="headerlink" title="1. ISO分层"></a>1. ISO分层</h3><p>应用层、</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-Redis的数据结构"><a href="#1-Redis的数据结构" class="headerlink" title="1. Redis的数据结构"></a>1. Redis的数据结构</h3><p>主要包括：string、list、set、zset、hash、hyperloglog、geo、bitmaps、stream</p><h3 id="2-zset的底层数据结构"><a href="#2-zset的底层数据结构" class="headerlink" title="2. zset的底层数据结构"></a>2. zset的底层数据结构</h3><p>zset的底层数据机构是基于压缩表（数组）和跳表的。</p><blockquote><p>什么时候使用压缩表？ 什么时候使用跳表</p><ul><li>当节点数目小于128</li><li>节点长度小于64的时候使用压缩表</li></ul></blockquote><h3 id="3-简述跳表查询某个元素"><a href="#3-简述跳表查询某个元素" class="headerlink" title="3. 简述跳表查询某个元素"></a>3. 简述跳表查询某个元素</h3><p>首先从高层往底层查询，每一层查到小于该目标元素，就调到下一层，直到找到该元素</p><h3 id="4-zset为什么用跳表而不是用二叉树或者红黑树"><a href="#4-zset为什么用跳表而不是用二叉树或者红黑树" class="headerlink" title="4. zset为什么用跳表而不是用二叉树或者红黑树"></a>4. zset为什么用跳表而不是用二叉树或者红黑树</h3><ul><li>首先跳表支持快速的范围查询</li><li>跳表的实现比树简单、易懂</li></ul><h3 id="5-mysql为什么用B-树而不用跳表呢？"><a href="#5-mysql为什么用B-树而不用跳表呢？" class="headerlink" title="5. mysql为什么用B+树而不用跳表呢？"></a>5. mysql为什么用B+树而不用跳表呢？</h3><ul><li>B+树每一个叶子节点可以存一条或多条数据，而跳表只能存一条数据，对于多条数据的查询，B+树的IO操作就会少很多</li><li>B+树中，根节点到任何一个叶子节点的路径是固定的，而跳表的头结点到目标节点是不固定的。</li></ul><h3 id="6-持久化机制"><a href="#6-持久化机制" class="headerlink" title="6. 持久化机制"></a>6. 持久化机制</h3><ul><li><p>RDB，是Redis的默认的持久化机制，是一种快照</p><blockquote><p>手动触法或者自动触法，文件小，恢复快，但是不能做到实时的恢复</p></blockquote></li><li><p>AOF，是日志的追加备份，是一种可读的文本文件。</p><blockquote><p>AOF文件会逐渐变大，所以需要定期重写AOF，为其瘦身，恢复的速度比较慢</p></blockquote></li><li><p>RDB-AOF混合模式，AOF文件的开头会写入RDB格式的数据，既保证数据的完整性，也加快了恢复操作</p></li></ul><h3 id="7-主从复制"><a href="#7-主从复制" class="headerlink" title="7. 主从复制"></a>7. 主从复制</h3><p>包括全量复制和增量复制</p><ul><li>全量复</li></ul><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><ul><li>cookie存在浏览器，session在服务端；</li><li>cookie只能通过保存在浏览器中实现，而session可通过tomcat、redis、数据库等各种第三方实现；</li><li>cookie中保存的数据不安全，cookie存在被篡改和伪造的欺骗攻击；session数据保存在服务端的，安全可靠；</li><li>cookie不会影响服务器性能，session过多会影响性能；</li><li>cookie大小限制是4K，session则受内存等存储介质的限制。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/22/hello-world/"/>
      <url>/2023/09/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
